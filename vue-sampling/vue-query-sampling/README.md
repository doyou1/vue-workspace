## vue-query sampling
- reference : https://vue-query.vercel.app/#/

### Overview
- Package migration
    - 이 패키지는 https://github.com/TanStack/query 의 일부로 마이그레이션되었습니다.

    - v1을 계속 사용하는 경우 마이그레이션 가이드에 따라 @tanstack/vue-query로 전환해야 합니다.

    - v2를 이미 사용 중인 경우 package.json과 import 문 모두에서 vue-query를 @tanstack/vue-query로 스왑하면 됩니다. 모든 것이 이전과 동일하게 작동합니다.

- Overview
    - Vue Query 패키지는 Vue에서 비동기 데이터를 가져오고 캐싱하고 업데이트하기 위한 후크를 제공합니다.

    - Vue 2.x 및 3.x 지원은 Vue-demi 패키지를 통해 제공됩니다

    - 리액트 쿼리 기준. 메인 패키지에서 모든 메인 컨셉이 상속됩니다. 리액트 쿼리 문서도 확인 부탁드립니다

- Motivation
    - Vue는 서버 데이터와 의견을 제시하는 상호작용 방식을 제공하지 않습니다. 따라서 개발자들은 지나치게 복잡하거나 기능이 부족하거나 이러한 용도로 설계되지 않은 글로벌 상태 관리 라이브러리를 사용하는 경향이 있는 맞춤형 솔루션을 구축하게 됩니다.
    - 대부분의 전통적인 상태 관리 라이브러리들은 클라이언트 상태와 함께 작업하는 것은 좋지만, 비동기나 서버 상태와 함께 작업하는 것은 능숙하지 않습니다. 서버 상태가 완전히 다르기 때문입니다. 우선, 서버 상태:
        - 사용자가 제어하지 않거나 소유하지 않은 위치에서 원격으로 유지됨
        - 가져오기 및 업데이트를 위해 비동기 API 필요
        - 공유 소유권을 의미하며 사용자가 모르는 사이에 다른 사용자가 변경할 수 있음
        - 신중하지 않으면 애플리케이션에서 잠재적으로 "오래된" 상태가 될 수 있습니다
    - 애플리케이션의 서버 상태 특성을 파악하면 다음과 같은 문제가 더 많이 발생합니다:
         - 캐싱... (프로그래밍에서 가장 어려운 일일 수도 있습니다)
         - 동일한 데이터에 대한 여러 요청을 단일 요청으로 중복 제거
         - 백그라운드에서 "오래된" 데이터 업데이트
         - 데이터가 "오래된" 시점 파악
         - 데이터 업데이트를 최대한 신속하게 반영
         - 페이지화 및 데이터 지연 로딩과 같은 성능 최적화
         - 서버 상태의 메모리 및 가비지 컬렉션 관리
         - 구조적 공유로 쿼리 결과 메모하기

    - 이 목록에 압도되지 않았다면 서버 상태 문제를 이미 모두 해결했을 것이고 상을 받을 자격이 있을 것입니다. 하지만 대부분의 사람들처럼 아직 이러한 문제를 모두 해결하지 못했거나 대부분의 문제를 해결하지 못한 채 겉만 보고 있는 것입니다!

    - 뷰 쿼리는 서버 상태를 관리하기 위한 최고의 라이브러리 중 하나입니다. 제로 구성으로 즉시 사용할 수 있으며 애플리케이션이 커짐에 따라 원하는 대로 사용자 지정할 수 있습니다.

    - 뷰 쿼리를 사용하면 서버 상태의 까다로운 문제와 장애물을 극복하고 제어를 시작하기 전에 앱 데이터를 제어할 수 있습니다.

    - 좀 더 기술적인 참고 사항으로 뷰 쿼리는 다음과 같습니다:
        - 응용프로그램에서 복잡하고 잘못 이해된 코드의 많은 줄을 제거하고 뷰 쿼리 로직의 몇 줄만으로 대체할 수 있도록 도와줍니다.
        - 새로운 서버 상태 데이터 소스를 배선할 염려 없이 애플리케이션을 보다 안정적으로 유지하고 새로운 기능을 쉽게 구축할 수 있습니다
        - 애플리케이션이 그 어느 때보다 빠르고 응답성이 높아지도록 함으로써 최종 사용자에게 직접적인 영향을 미칩니다.
        - 대역폭을 절약하고 메모리 성능을 높이는 데 잠재적으로 도움이 됩니다

- Installation
> npm install vue-query

- Using `VueQueryPlugin` (recommended)
> import { VueQueryPlugin } from "vue-query";

> app.use(VueQueryPlugin);

- Use of Composition API with `<script setup>`
```javascript
<script setup>
import { defineComponent } from "vue";
import { useQuery } from "vue-query";

const useTodosQuery = () => useQuery("todos", fetchTodoList);

const { isLoading, isError, data, error, isFecthing } = useTodosQuery();
</script>
```

### TypeScript
Vue Query는 라이브러리와 프로젝트가 안전한지 확인하기 위해 TypeScript로 작성됩니다!

주의해야 할 사항:
- 현재 필요한 TypeScript 버전이 v4.1 이상입니다.
- 이 리포지토리의 유형 변경은 중단되지 않은 것으로 간주되며 일반적으로 패치 서버 변경으로 릴리스됩니다(그렇지 않으면 모든 유형 향상이 주요 버전이 됩니다!).
- vue-query 패키지 버전을 특정 패치 릴리스에 고정하고 모든 릴리스 간에 유형이 수정 또는 업그레이드될 수 있음을 예상하여 업그레이드하는 것이 좋습니다
- Vue Query의 비타입 관련 공개 API는 여전히 sember를 매우 엄격하게 따릅니다.

### Important Defaults
- Vue Query는 공격적이지만 정상적인 기본값으로 구성되어 있습니다. 때때로 이러한 기본값은 사용자가 모르는 경우 새로운 사용자의 허를 찌르거나 학습/디버깅을 어렵게 만들 수 있습니다.

Vue Query를 계속해서 배우고 사용할 때 이 내용을 기억해야 합니다:
    - `useQuery`를 통해 인스턴스를 쿼리하거나 기본적으로 `useInfiniteQuery`를 사용하여 캐시된 데이터를 오래된 것으로 간주합니다.

> 이 동작을 변경하려면 `staleTime` 옵션을 사용하여 쿼리를 전역 및 쿼리별로 구성할 수 있습니다. `staleTime을` 더 길게 지정하면 쿼리가 데이터를 자주 다시 불러오지 않음을 의미합니다

오래된 쿼리는 다음과 같은 경우 백그라운드에서 자동으로 재패치됩니다:
     - 쿼리 마운트의 새 인스턴스
     - 창에 다시 초점이 맞춰집니다
     - 네트워크가 다시 연결되었습니다.
     - 쿼리는 선택적으로 refetch 간격으로 구성됩니다.

- 예상하지 못한 재패치를 보게 되면 방금 창에 포커스를 맞췄는데 뷰 쿼리가 `refetchOnWindowFocus`를 하고 있기 때문일 가능성이 높습니다. 개발 중에는 특히 브라우저 데브툴과 앱 사이에 포커스를 맞추면 패치도 발생하기 때문에 이 문제가 더 자주 트리거될 수 있습니다.

    > 이 기능을 변경하려면 `refetchOnMount`, `refetchOnWindowFocus`, `refetchOnReconnect` 및 `refetchInterval`과 같은 옵션을 사용할 수 있습니다.

- `useQuery`, `useInfiniteQuery` 또는 쿼리 관찰자가 더 이상 활성 인스턴스가 없는 쿼리 결과는 "비활성"으로 레이블이 지정되며 나중에 다시 사용할 경우 캐시에 남아 있습니다.
- 기본적으로 "비활성" 쿼리는 5분 후에 수집된 가비지입니다.

    > 이를 변경하려면 쿼리의 기본 `cacheTime`을 `1000 * 60 * 5`밀리초가 아닌 다른 것으로 변경할 수 있습니다.

- 실패한 쿼리는 자동으로 3번 재시도되고 기하급수적인 백오프 지연이 발생한 후 UI에 오류를 캡처하여 표시합니다.
    > 이를 변경하려면 쿼리에 대한 기본 `retry` 및 `retryDelay` 옵션을 3이 아닌 다른 것과 기본 지수 백오프 함수로 변경할 수 있습니다.

- 쿼리 결과는 기본적으로 구조적으로 공유되어 데이터가 실제로 변경되었는지 여부를 감지하고 그렇지 않은 경우 데이터 참조는 변경되지 않고 그대로 유지되어 가치 안정화에 더 도움이 됩니다. 이 개념이 이질적으로 들린다면 걱정하지 마십시오! 99.9%의 경우 이를 비활성화할 필요가 없으며 이를 통해 제로 비용으로 앱 성능을 향상시킬 수 있습니다.
    > 구조 공유는 JSON 호환 값에서만 작동하므로 다른 값 유형은 항상 변경된 것으로 간주됩니다. 예를 들어 큰 응답 때문에 성능 문제가 발생하는 경우 `config.structuralSharing` 플래그를 사용하여 이 기능을 사용하지 않도록 설정할 수 있습니다. 쿼리 응답에서 JSON 호환되지 않는 값을 처리하는 경우에도 데이터가 변경되었는지 여부를 탐지하려는 경우 `config.isDataEqual`로 데이터 비교 함수를 정의할 수 있습니다.
